{\rtf0\ansi
\ansicpg1252
{\fonttbl
{\f0\froman\fcharset0\fprq2 Times New Roman;}
{\f1\fswiss\fcharset0\fprq2 Arial;}
{\f2\fmodern\fcharset0\fprq1 Courier New;}
{\f3\froman\fcharset2\fprq2 Symbol;}
{\f4\fswiss Helvetica;}
{\f5\froman Times;}
{\f40\froman\fcharset238\fprq2 Times New Roman CE;}
{\f41\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f43\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f44\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f45\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f46\fswiss\fcharset238\fprq2 Arial CE;}
{\f47\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f49\fswiss\fcharset161\fprq2 Arial Greek;}
{\f50\fswiss\fcharset162\fprq2 Arial Tur;}
{\f51\fswiss\fcharset186\fprq2 Arial Baltic;}
{\f52\fmodern\fcharset238\fprq1 Courier New CE;}
{\f53\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f55\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f56\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f57\fmodern\fcharset186\fprq1 Courier New Baltic;}
}
{\colortbl
;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
\red0\green0\blue128;
\red0\green128\blue128;
\red0\green128\blue0;
\red128\green0\blue128;
\red128\green0\blue0;
\red128\green128\blue0;
\red128\green128\blue128;
\red192\green192\blue192;
}
{\info
{\title  }
{\author Theo E Schlossnagle}
}
\paperw12240\paperh15840\margl1800\margr1800\margt1728\margb1440
\sectd
{\header
\pard\qr\tqc\tx4320\tqr\tx8640\plain\f0\fs20 Theo Schlossnagle\par
\plain\f0\fs20 jesus@cnds.jhu.edu\par
\plain\f0\fs20 http://www.cnds.jhu.edu/~jesus/\par
}
{\footer
\pard\tqc\tx4320\tqr\tx8640\plain\f0\fs20{\field{\*\fldinst{ PAGE }}{\fldrslt{
4}}}\par
\plain\f0\fs20\par
}
\plain\f4\b\par
\plain\f1\fs20\b
{\pict\jpegblip\picw16933\pich3810\picscalex35\picscaley35\picwgoal9600\pichgoal2160\bliptag-104948941
ffd8ffe000104a46494600010100000100010000ffdb004300080606070605080707070909080a
0c140d0c0b0b0c1912130f141d1a1f1e1d1a1c1c20242e2720222c231c1c2837292c3031343434
1f27393d38323c2e333432ffdb0043010909090c0b0c180d0d1832211c21323232323232323232
323232323232323232323232323232323232323232323232323232323232323232323232323232
3232ffc00011080090028003012200021101031101ffc4001c0000020203010100000000000000
000000000706080104050302ffc40052100001030302030306080a031002030000010002030405
1106071221311341712232516181910814153574a1b1c11623343742527273b2d1333692242538
43445354555662758293b3c2f026e1276484ffc4001a0101000301010100000000000000000000
00010304020605ffc4002611010002020104020105010000000000000001020311040512314113
2151327181b1c1d1ffda000c03010002110311003f007fa1084021084021084021084021084021
08402108402108402108402108402c6420f44bed4d557fb86be8b4f5baf62d54bf277c71d23210
f7bcf69c24027a2060e42321237585add61a182e2ed4b77adac6d54438a6a8c3402e19f25b81d1
35ecb7d8eeace2610507710b0b28042108058ce1657cbba20ce4232155ed43bedabcdc6ae929be
2b46d8657c7f8b8f89dc891d4f829b6d4ee2575ced3232f15aea9aa339c39f8c86fa103ad6578c
1289a20f1debd900842100842100842100842100842100842100b19016573ef75cfb658ae15f1b
1af7d35349335aee8e2d6938fa906fe4232aa95cb7eb58d765b0494b46d3d3b28b247b4a6ceda6
bb9aeda72885c2a8cf5aecf68f763279940d542f88dfc6c0ef4afb40210a0bba9ad2bf43e9886e
36fa7866964a8111ed73868209cf2f04139c84642a9551bd5ad2e5590b5d7065346646f13608c3
4632ac8583534576680c78710064fa504990b00e56500842100842100842100842100842100842
100842100842100842106328c851ed6d7ea8d33a46beef4b0c734d4ece26b242784f3efc2ad972
df2d697005b1d5c348c3dd4f1007de7282daa140f456af176b3dbd92cc659cd347da3c9e65dc23
3f5a9db4e46506508420108582e03a9010650b01c0f420aca01085f3c6dfd61ef41f4858c85940
210840210be78dbfac3de83e90b0083d082b280421080421083097ba878a2dd6b5481a3f1b699d
9c5fb2f69fbfeb4c22e68ea42806a620ee7583041fef755fdb1a0596e8cf27c981bc4706a19f7a
9e6d73defb7b1ce39e414037470281a3d352dc7d6983b5bf36b3c020670e8b2b03a2ca01084201
7cbba2fa587744147358c7d96b4bdb33fe5d31f7bc95dedb795edbb35809c710e4b93afa3ecb5f
5f599ce2b243ef395d6db66e6f0cfda082db5a3f218fc174168da862859e0b7900842100842100
842100842100842100842100b9f7a8fb6b1dc22071c74f2373e2d2ba0bc2ae21352cb11380f616
e7c46105074d3da7964f8fc6ce23c20f44acef4d4da400dc1be2105a4a4fc9d9e0bdd78528c53b
7c17ba012a7e101187edd711ce5955191f584d64b2df8635db6354e2325b3c447f69054f6f27b7
1e9564f689cf92005c49e8ab633cf6f8ab29b41f928f620740e816560740b28042108042108042
108042108042108042108042108042108042108225b9711976eaf8d1dd4ae77b82a5caeb6e27e6
f6fdf4393ec54a103d367def7c8c049200015888fcc0abc6ce79cdf00ac447e604112d7f7bbad9
6db41f24be08aa2aeb23a6ed67671b581dcb38ca8e5c6c5a80d3cb25d75b56b8b18e708a8a26c2
d240e99c13d576374c11a6a925691c515c2078e5fef2e46aaab7c123dd93c2d049c20e069cd51a
e750d9692db46d16d643106545cab5a5d2c8eefe169fb5764e8fb6c67b4badfaf171a8c7373eac
b1bec6b709372eb4d417f9cc3433c9474a7ba1f3dde2574a9b465f2ba31236b2bdaeebc467713f
6a060d55823a5719f4e6a0b95055b4e5ad92a0cb13b1dc415ed6dde0ad8295f6db8d9e6aad451c
9d9369e9587865f43f3dc14534dcb751515d67ba973ab28835c1e7ac919e84af7bdeaa934bd20a
c8e99b2d4bddd9333cb9e09e67ae3920997c9dac750344fa86ff00f23d3b864515b301c3d45e73
f52f0934a69b858e6beb2eb2bcf591f5cfe2294c6e1aab564bc75573aa20f48a9ddd9b07b96f0d
23aa6821756d055d576b18e2ecdef2f6bf1dc4141369a5bfe9126bb4eddea2e746ce72dbeb9dc6
ee1efe0775ca66695d5f41aa6d5157523b01e3ca61eac3de0fad29ed35efb8d9696e4cc812b32e
6fa1c3911ef5ced1f74758b5c5ca8633c34f33db3067702eeb8416332a21ac35dd3e9b960b7515
33ee57baafc9e861e6e23f59de80bad70bec169d355577a823b3a684c847a703a28268cb749416
e9b555e3325eeedf8e7b9fd618cf9ac6fa060a0fa759b54de59f18d4fa9a4b7c679fc4ad786068
f4179c92b9925b74453931bef352f783cdd25d0f17da973adf58dcb54df26b6d1cf247410b8b08
8ce0caeefc9f42d8b26d94d708439d0601f48413a1689299a27d33aaee14ef1e6b27984f13bdeb
b3a6f72eae2bb4762d5b4d15256c9f93d4c47f1351e1e8296f5fa5eefa0036e948f95f6e0e02a6
02721adfd61e0bb97fb7477cb3760f76789a25a6987563b1904140f98a564ad0e69057d9384abd
aed6335dad31c15cff00eec8098a5cf5e20a45b89a9ea6c563869ad6d125e2e728a5a2675f28f5
77801cd0786a5dc26dbee7f2258289d78bd1f3a18cf910fae470e9e0b90fb3eacba7e3750eab75
134f3f8a5ada181bea2e392bded76cb76df69f7b0481f56f6992b2b2439748feae24fa1263506e
05f354d73e9ed92c94b459c031f27c9ebcf7206acba6f4ec647c66ef76a8703cccb70773f76162
82dba7ed571171a29ea65a8631cc676d52640d6bb19c03e012b2ddb7d70ba0ed27eda4279e6471
767debb961d1d3d8f59c74678c76b42f9787271c9c020f2dca984f434ee1fe94cfbd3376bd98b5
b3c02576e14261b7d3b4ff00a537ef4d3db1f9a99e0103290b0841942c2106560f9a5083d0a0a5
1b89f9c4bf7d31eb4ec3a865b04867822649367c9e3e816e6e2fe712fdf4c7ae2dba89f5b3b58d
69773e8104b27dddd6b311c3797c0d1d1b0b1ad03ea5b36bde9d6b6d9839f726d6479e71d4c608
3ed183f5ae8db76daaabe10ef8b0008fd55ced43b5f71b6523eaa9e27b830713998eef52075e85
de3b6eaa2da5aa60a3afc7389cec87fec94cd8a664ad0e61047a550ba6a99a8aa593c0f7472c6e
e26b81c1055a2db1d706f96e884ef1da81870f5a06b1e8abfeadf840d7d15ceaadf64b5c0dec24
74667a925d920e321a084ff0ee26e42aeba9368e1a1adaaab74b2d64d3cae900c70b5b939c63bd
0426b37935cd63893797423b9b0c6d601f5657953eee6b7a69448dbecd211fa32b5ae1ee2149e8
36c6aea3fc4068f470ac5fb692a29ed73d546c2d7c4c2fe5df819fb904b7426fa9bad5b2df7f86
28277e03278b218e3e820f429d74b59155461f1b811e2a85b5ee63c3da70e07208ee2ace6d5ea9
96e3430c733f2ee119c940e0ca85ebbdc9b3686a702a5df18ae90663a58dde51f59f405d7d5ba9
29f4b697abbbce41ec59e4349f3de7a0f7aa5d79bc565f6eb3dc6be574b51338b9c49e9ea0827f
7adf7d617495df149a0b7439f2590479763d6e767eac2e247bb3ae237878d415048ee70691eec2
8f5b6d7256ca1ad61713dd853eb6ed7d5d6441ce808cfa907674aefe5f9b5d4f4978a7a7ab8e47
8676ac6f03c67bfd05581a0bb4171a7e289c0e42ac557b5570a2a88a6803870b812309cfb7f4b5
74f485951c5c877a0a949abb49f9737c52a934b6a2664153db4af6b2360e273dc701a075250592
bbdf6874de9f9ae970943208599ebcdc7b80f5955d2afe103abe5ab94d2b282280b8f66c301240
eec9cf55cadd2dc59758dcdb4548f2db45212226f4ed5dfae7ee50fb55be49e6638309713e48c7
d682c96dd6b6bddc689d36a1ab8659e620c5147186f037d78ef2b6b7be5ed76aeadde99a2fe25c
7dbbd293b58da8a8e2cf2eabb1be1188b6aaada3ba68bf8820aa2cf3c73c734ceb06e93349d008
e868c555491d642431beee652bd766d16735cf1c51bde7b9ad412daedefd735b29736e3152b3b9
9040d007bf27eb5ed68df3d656fa96baaaaa1ae873e547346067dadc10b14fb6b55591f13694b0
1f42876a4d3959a6ebdb4f54c203dbc4c711d420b59a2771edbabe804d09eca6181242e3cd87ef
5376b839a083c9528d0f7b9ecba8237c4f2d6c9e4b8771f42b75a62e7f28db6379392420d6d75a
c21d11a6e4bbcd4eea8c3db1b636bb1c44f4e690176f840eadad738504545411f77047c6ef7bb9
7d49efb8da4bf0c74d7c98ea930344cd94b9adc938ee48aacdb3f8ad5761474cf7b472e37f3250
4664dd8d7123cb8ea0a919e7868007bb0bab67df1d656c99a6a6ae3b8439f2a39d833ec70c1522
a7da6a99a3cbe21cc7a14135de8b9b49d453170223a9e2e107d2319fb420b2da2b71edbac2804d
09eca66f292171e6c3f7a9b35c1cd04730a95686bdcd66bfb1f13cb5920e170cf5f42b73a66e5f
285b9926724840b3dc2dedafd27a92aac94369a791f006fe3a679c1c8cf9a3f9ae168ddf3b854d
cab66d4f534f1d1b210628e18b1e567bba92a25beb1066e755b87e9c111c7b30970c697b834754
0ecd43f089ba4ee74560b7c34f183ca6a81c6e3e0de83eb50d7ef2eba7c85ff2db81ce7022601e
ec2d0b36957d7b07674ce91c7f49dd3dcbb953b59707d33a4861735e0640c7228243a4f7feed0d
5320d44c86a29dc40ede36703dbeb20722ac05aaf54976a664d4f2b5ec780e6907a8545e58df0c
af8a4696bd84b5c0f711d539b67b54cf0b19432c84b58ec373e8416572b4ee975a1b3504b5d70a
a8a9a9a21974923b007ff6bd629daea6ed5ce01a06493dc154bdd6dc0a8d61a824a7a795c2d54a
e2c8180e03cf7b8fa728279a9be1125933e0d376e8dec0702a2af383eb0d18faca80d5ef4ebaaa
7977cae2207f462858d03ea505a7a77543f032a6565d0d577100b69ce0f790834eaf73357d750c
f45557a9e6a79d859231e0105a7bba28994d0bdedacf6cd3f555ef8b0218f88f24af3d503e7671
9e503e0ac147ca36f82406ce7e8fb15806798df0410add66e743cb20243a3a981c31e9ed1aa3fa
d1b86cff00b0efb148b757fa8755fbe87fee3547f5af993fec3bec40b3da8b543592c6e91a0ab1
f476ba6821686c6de9e8481d9beacf056322fe8da81677cb74516eac2636e3b7b53f8c01d785e3
1f6a5a6e653b5b474c31d2a9bf614d9bf7e75287fe152ff184addd0fc969fe94dfbd04e76d6c94
afb7b247301384cff93a9fb3e1ecc6140b6c7e6a67804c84096d3f40c874edc2260f222b954b1a
3d038cf250199ee8f721d8e5f8a8fef4ccb1fcc377ff008ad4ff001a58d67e729dfbb8d03635c3
9d53a128aded2715d5b053bbd60bb247d4bd759d7fc4e8656c7e4b2188f081e80392f2d5920874
fe9f99c3c88eeb4ee778731f7ad0d744ba9ab1bcc9313c01ec40b0db3b38b8d6b649471127249e
f2acf5aedd0d25331ad6018090db38c0e0c3ea0ac447c981073af76982ed67aba1918d2d9e2733
9fac25069f61a8d076c95fce48986177fcae23ee4f07901a49e8073f049dd358934145281e4c93
ccf6fac17b9042f4b559b5ebfb8d3b4e1b248c900f594c7e3f96775c4d27950d92da1d18ee12ca
4f3f1c03ee4a78e5ff00f24cfc3d1a180fb933b4f4a19ab755308c48e8291d93dede17fdf94114
ddcbd4bf260a489e41a897b338fd51d578ed9690654964d2c791e0b97b95992a6d85c323e30e07
dc9bdb6d4ac8ed519039e02098d0da69e9226b5b180a1d7c8d8ddd5b786b401f23cdff0071a984
a017efceb5bffe0f37fdc6a0566e872a4a7fa533ef4c9db1f9a99e012db743f2583e94dfbd3276
c7e6b678040c942108042108041e85083d0a0a51b8bf9c4bf7d31eba1b754ec9eecc0e00f94b9f
b8bf9c4bf7d31ebabb69f3bb3f6820b5b67a1823a1670b0745b3556e82a222d746398f422d9f91
47e0b6cf4414935ddaa3b26b7bb5042de18a39c960f403cfef520dadbabe8eedd90761a5c0e172
7732b63afdc7be4f11059f192c047fbbc8fd60af9d0b917a611fac105c8b6cddbd1b1fea50fd65
b89a4b4cbdd0d7d509eb07f93c038ddedee1ed51adc8d7551a4344d2d3d0bf82e15f9631fdec68
1e53beb03daab43df2d5ce5f23dd24af39739c7249f5940e6b97c20ea412cb358e9e16f73ea5c5
c7dc31f6a895d7793595d6096092b6086195a58f6430340208c119393f5ae1dab4dc95ce02389d
293ee52e6edc5636dd3ce69c35b1c6e79e5e819fb902b93a36765709d8dcf2e492e9c7b3bf9537
d8824bf08abb3e2b3592d6c7605448f99e3d21a001f5b957a89bc72b5be929d7f08c6bc5d2c121
1e41a7940f1cb7f9a4d5000eae881ef3840f0dadd271d406cf2c60f4ea9f54b6f829e20c6c6392
82ed953b23b4c6e03b8262a0d6968609461d1b5622a28a9987b3681e0b6961fe61414096fb6e93
436e3470b8b1b27f484778f42d05d4a6b54d5d42e9606173e319c0ef083568616cf500388e5d07
a53af6ef451ab959533c791e091d148e8266c8cf39a72159eda7d4d4771b5b030b5b237939bde0
a068d050c7454ed8d8d03014037dbf35d59fbe8bf89325ae0e19096dbedf9aeacfdf45fc482a63
465c07ad3f36a6c14d551b6491809e5d424233cf6f8ab2bb41f928f6206d53db29a08c35b1b709
1bf08db7c30d258ea58d0d7992561c0ea30d3ffbe29fc3a048df849fccf62fdfcbfc2d415fade7
86be123b9cada6da4c64b43327b82a9343f96c5e2ad86d87cd2cf00827b5d594b4548fa8ad9e38
2060cb9f23b0024eea1deed2b6c99ccb5524972947f8c038199f13d52e77835f55ea6d49516da6
9dcdb550c86263187948e0705c7d3cc724bca4a4754bbbc0f577a0685c3e101a9a72450d1d0523
3bb31991def271f52826a5d657dd5ae80de6b04e202eec808dac0dce33d00f405dbb4e87a9ae0d
31d2b883dee5afadf4acda6e9e85f2c7c1f1873c0e58e98fe682316c770dc213eb56df6e242fb3
c7939e41547b77e5f178ab69b69f34c7e010263e104c2ddc38ce31c546c39c75e652e6c9089ee5
1b08e44a66fc227faf745f406ff1b92df4e7cef178a0b4da134ed2476d8e431349c75c29c3a820
31f0f66df72e168af99e2fd90a4e7a20a51b894aca2dc2be53c630d6d53b1edc1fbd6f6dcca63b
d3704f9c178ee97e73afff0049ff00c42fadbef9e99fb410588dc0bdbecdb5970a88dc5b2cb108
5a41e79772fb1547272acbef2879da8670e702a22e2f0e6ab40f3878a060edfe9af956b99c4ccb
411dcace58f4f52dbe958d1137200ee4a8d9fa267007e39a7b3400d01043b73a18dbb717b2d680
453b9533573f743f36f7bfa3b953040fdd9ceef62b00cf30782aff00b39ddec56019e637c10433
757fa8753fbe87fee3547f5af9937ec3bec5dddd4e27e8dec83b024ab81a7c38c2e36ad00cce04
6473f6a0806cdf58d58c8bfa36aadfb36e2d91ad3c88383ef56422e71b502fef8f6bb75a8da399
6da6527974cbc612bf743f25a7fa537ef4d0ba3da7761e0119166e63d1f8c2961b9cde2a08ddcf
c9a9611ef40cadb1f9a99e013212d76c1dfdea672ee0994814962f986eff00f15aafe34b1acfce
53bf771a66e9ee23a62e32b88fc65d2ac8c7762423ee4b3b9f91b8b19c638a169cfb4a070eacb5
cd75db3aa6d334baa606b6a2203af130f17dcb815370875059292e50bb8d951102ef51c731ef4c
ad3e04b6a6348c82dc10528350daeb36eeed3b9b0c93e99ac90c9860c9a479ebcbf55071b6c2a0
59b50d4da2a4f04b13ff00161dfa4cee2158f81e1f13482abc54daed9a88c55b495bd9d447ce1a
ba777943d47d3ed52eb4d7ebda7a4f8b4777b3ce0726cd3c4e0f03c07228265b87a962d39a56a5
ed7835d52c3052423ce924772181eaca8bba8d9a6744d0504ee0d34d4e3b524f20ec65df5af3a5
b1414572fc23d5979174b8c4dfc519006434ff00b2d4b5dc2d7a753cceb5d9dce7539389a703ce
1e81ea41ccd1c5f78d5d3d7004b659b89b9f46792695e41d3bafed55b2e5b4779a3344f791c84c
d39667c41c7bd7236bf4a3a1e19df1e3a6134b58e94835469896db2131c83124128eb1c8de8420
4eebbb44d5f412081a4d440f12c63bc91dca69b4fa8a96e36c6c4d903668f0d7c6ee4e69f46143
60becf054fc8fa8dbf14bb43e4f68fe4c9c77381e8bdc69eb5d4d68ac63ea286b3fd228e52c27c
474282c071343492401e94b3adbc5beedbb31b6df54ca9f89daa58ea1d1f36c6e3234804f4ce17
27e428eae9f86ebabef53d301e547db363047a09017cda353690b7be6b169a8a36398d2e91d182
78b1de5e79b9044f7406686339f36a5a7ed4c8db077f7ad9e012c370e533d9fb4cf313b0fd6993
b5aecdb59e01033d08420108420107a1420f4414a3717f3897efa63d74b6d9d8bc37f682e36ba2
e76bbbe39c727e3b2ff115ab63bf4f62aa13c11b1ee07387f44176ad673431f828cee3ebda2d15
a7a697b663ae52b4b6960ce4977eb11e8090953bedaba4a5f8bd21a5a36e31c51c7977bca5f5c2
e570bd56baaabea66aaa879e6f91d928352591f34cf924717c8f71739c4f324f54c1db6b4bea2e
91bb8490082a2b6ab2cf593b5ad6124f72b17b6fa3fe4f85b34b1e1c708173bfb14b0ddec8c767
b214aee0cf4cf10cfdc9576c6092ba361fd2e4ace6f668c9751e9a86ae8e3e3aca025cd68eae61
f387d43dcaae0ed29e5079b2461ef1cc14169b6ef4bd236df1cae8da4919538bf5253c1a6ae786
b5a0524bcffe52ab669cdebbce9fa36d39a2a7a8e118e2712dfb1686a8dd9d53ac21344f95b4d4
8fe4e8299b8e3f13d4840bf4e3d9efca99ec49c4e1d9e70f8d37d8826dbf9617dc348d1dca2671
3a86425f8ebc0e001fb02ad91486199920ead3957a2e16e86eb68968ea236c90ccc2c735dd082a
a1ebbd095ba46eb23781f250bc9314b8ce07a0fad03e36a2f1055daa30c901e41358107daa8f69
cd5b77d2d55db5b6a3841f3a370cb5dec4c867c226fcca6e016ba332e3cf25d8f720b295355051
c0e9ea6664513465cf7bb002cf68c922e263839ae190477854db506e36a4d615514774ae3f16ed
01f8bc23823ebe81d7daac5e9dd546ba89fd9f31145e48f0082a1a676d753b2a2a431c0107960a
58a686d33f17160f5a0d0dd1d10fd31771594d1114156496e07263bbc2e068fd4d3699bcb2a1ae
3d838812347a3d2ad7ea8d2f4baa34d4b4352c043d9e4bbbdaeee2153ebd59eaac576a8b75630b
2585dc3e23b8a0b99a5efd05dedf1cb1c81c1cd0720a8aefbbdaddb1aa04e0ba7880f5f9493fb5
3aea4b457b2d95529ec5e7f1449e87d099bbdb58caddaf3230839a98fef41585be70f15657681d
9a56fb156a1d42b1db3aff00c40f620770e81237e127f33d8bf7f2ff000b53c879a1237e127f33
d8bf7f2ff0b5057da1fcb62f156bb6c8e2cecf055428ff002c8bf682b5bb60e0eb3b47a9054f9f
b5f8c4bdb67b5e33c79ebc59e7f5a9aededb22b95c236c98203b056ceed68d9f4deaba9aa8a1fe
f7d648e963781c9ae2725a7d1cd44ac3a82b74ed70aaa42d241e6c70e4505c9b2d82928e919c31
37207a127fe1251c71d3e9d6b00078ea3207846b847e10b7f651f654f6ea46498c07bb2ec7b12d
b506a2bcea7acf942f155254487934b861adf501d020d0b77e5f178ab69b69f3433c154bb79c57
c5fb4ad9eda387c90cf040a1f8457f5ee8be80dfe3725b69df9de2f14c2f841b9cedc288139028
d807ab9b92eec071768bc505c2d15f33c5e0a50a29a1dd9b3c5e014ac9c0414c374bf39d7ffa4f
fe211b7c717a67ed046e97e73aff00f49ffc42f8d04717a67ed04163f5ad95d7edb0afa4899c53
087b4601facde6aa29041c118239615e6b3b04b696348ead559f75f6eea34fde66b95042e75ba7
717bb8467b271fb904ab666f50b9a222f0246f270cf3560e37b5ec041c85442db75aeb3d5b6aa8
2a1f0ccdfd26a6152efc6b0a6a5ec41a37bb1ca4745cfed40fddd49a2876e2f22491ace380b5bc
47193e854d1483516b2d43aba5ed2ef5f2d4359cdb181c2c678347251f27281f7b36ef37d8ac0b
3cc1e0abbecdbfca60f50561e3f3020e56a5b0526a4b3bedf5a651139c1e0c4ee17020e410526f
51edbd5b672292bae2ff005c952e713f5a7daf37d3c4f397341f6204f680d133d9251c4d200f4a
71c63863017cb208d9e6b405e88213ac34351df6b7e551515b4f5a21ec0be9a72ce26673838f5a
51d76da57cb581a67aa9616b81e19257387d6ac8901c3042f234b09392c19f04111d116596d746
d63c63014d17cb18d60c0002fa40a4d4db654ec13bedd597289b34af98c2da97060738e4903c4a
8759f6e6b61bbb6a6674b23872e291c5c71ed5629f1b1fe70caf314b08390c03d8834acb4c6968
591b86080bdae36e86e14ce8a6635ec70c10e19056e001a3002ca048ea1da48a2a9754da1d3514
84e7fb9de5a0fb145e5d3dace8b31c778ace1f4e013efc2b28e8daeea16bbedf4ef3ce36fb9056
397455feeaf1f1fabacaaf54b2123dca5fa676bbb395af9e3000eec27636db4cc391137dcb6190
b19e6b4041ceb45a21b6d3b58c60180ba98ca108225ab7455b752d37055d2b2523cd711cc781ea
128ee1b6f7ab4bdc2d773ac8a3ee617f101ef562579494f149e7307b9055ca8d19a96b9dd9d6d7
55cccfd573c81ee5d4b7ed55600258e49a9de1bc3989dc248f5ab13f26d3673d9b7dcbd9b4d134
60307b9056b9f6c6e2f983249ea658c1cf0be42426b690a6a5d390320adac8207e010d9240d38f
6a9efc561272583dc967acec1583593aeedd3b4777a1342d803279437b3787124807d4504fff00
08acdfeb6a2ffaedfe68fc22b2ff00ad68bfebb7f9a4654dda9e094b5fb7d6b691e8783f72f0f9
7a93fd81b67f687f240fafc22b2ffad68bfebb7f9a3f08acbfeb5a2ffaedfe690bf2f52ffb036c
fed0fe48f97a97fd81b67f687f240fafc22b37fad68bfebb7f9ad9a5b9515787fc52ae19f83cee
ca40ee1cf4ce157cf97a931fd40b67f687f25d8d09749a9352dd6ad96b8add056b606b6084e5a0
b38f27dbc483735d6d45a2b2aaa2ba8e8dcda99de6491e2471cb8f33cb296726d5d735e7113f0a
d553f05540d73db9c8ef5f46829cff008a6fb905568f6beb33834e4f8aee5b76a2a9ee1c71f08f
52b1a2829c1fe89bee5e8da7899d180205d699db8a5b6f0be48c170f4a61d3d3474d18631a063d
0bd490c6e4f20171aab51d253b8b78b24289b4479598f15f24ea91b75a785b3c458eef092baef6
a68ae150faba7844533b24ba3e59f1098526b1846405c5b8ea375479a792aad9ab1edbb174ccf7
9d4c68859f6d2e10c8406bdc1756d1b755ee25a212d079138e653760bcc2223da46d2ef05b94b7
e818dfe89a0f82467a4babf49e444fd414159b412c2c1d946f27d6e530dbed155566aa05ec2005
3b8751d3bc812b5aba32df68a0a7e388378bd4175196b3ed45b819eb3ad2450b7110057175069c
a5bd52be29a263c38630e195a349aba1767b4380ba94ba8292a5d86bb9a98c959f6e2fc2cf4f35
213526ce08e773e8e374633d1a79287c9b6b7089f831bc856f4c514edc968395aeeb4d238e4c4d
f72ed9557ed5b6d5c65691063d64276e8dd26eb6513a399b90f6e082a6f1dba9a2f36268f62d96
b434600c20af5aa3672db48ec5ae9e503fde90b96ce83d095568ae6bdcc200394f8929e293ce60
3ec58652c31f36b003ea080a78f869dad70ee4b5dc3db6b76a39c57ba9cfc69ade1e26bb191eb4
d058731af1870ca0ab11ed5d54158d7885d86bb23994da8f49b2ff00a60daaf11c924396bb0d71
69c8e898c68a0273d9b7dcbd1b0c6c180d010568bded208ab08a1a77363cf21c44a64edd6999ec
ec024690996ea481c7258095f6c8638c792d0107d8e8a25aef465b357d0c0cb8c2f90d3173a2e1
796e09033d3af40a5cb04070c1082b0d5ed4be1b8e696073630ec8e64a74684b3cb6ba16b2418c
052f347013931b7dcbd991b19c9a0041c2d4da7696fb6f7d3d4c2c95ae1cc386557dd45b3f252d
43dd44d7b59dcdce70ad0fb1784b490cc3cb603e210544876e6bdb261d0b9de2a4d06d65557d33
5b3b1c0339b43792b1a2d1480e7b26fb96c3292160c06003c1055f6ed555415ad732376014f6d0
f6996d940d8e418202949a3809cf66df72f6646c60c346102e770b6ead3a96abe539e9defac118
8c383c81819c72f6a5351ed7d4d35cdb247138341e5cd59f7b1af1870caf11470039ecdbee41c7
d2b40fa0b6b2378e6005203cd61ad6b460059409cd79b5769b8d7555ce0a590d5d4bb8e4776871
9f4e143f4cedcd5dbeead93b221a1ddeac84913241873415e6da481a721832835ed303a0a2631d
d405e777b44373a67c72b038118e632ba400030167920af3aab672233be6a284c7939c33a7b941
64db3b8c5263b37b82b7b2431c83ca682b55d6ba579c989bee4159ad9b615b3c6637c458c775c7
7a2bb68a78081146f3ed567a3a2822f36368f62cba92171f2980fb1028b6e74854d9646f68c200
c271b061802f3653c51f9ad017aa0ca1610832858420ca1610832858420ca1610832858420ca16
10832858420ca1610832858420ca1610832bc2a29db51196b86415ec841189f47d1ccf2e746dc9
f52f2fc09a1ff34df729621044ff0002687fcd37dc8fc09a1ff34df729621044ff0002687fcd37
dcb669749d1d3481ed8db91ea523420f88a2113034772fb42106560a10ee850716f177a7a689f1
b9f87e12beb6a5d2d439c1c48caeeeaf8e56d7971ce0a8c2f9d9ef336d3d974ae2d31e2f923ee6
5a76fbb535d592be9652f113f81d918c15b9c443492790511d03f92dcbe96e52d7f28dde05557a
c45b4ddc6cb3970c5ede65ad6dba525d69df352cbc6c638b5c48c6085cb935cd921a8743dbc8e0
d38748d8c9683e2b89a5a29ea347dd60a63899ef91ace7de42c699b9594d8fe45ae8d94f5382c9
5b2b40e227bf3e956fc758db04f2f2dab4d4c46e37b9f1bfc2790ceda881b342f0f8dc32d703c8
85cab96adb75aa4305454b9d2ff9b8c1710b42e52b749e8e91b452bddc0386273c8241715cbd39
2e9eb6d14735457d2c95d300f96491d97071eee7e8515a46a656e4e45bba317d44eb7333e23feb
b943abed5719c411d43a394f464ad2d27dea4b6fab7c13b5dc4719507bd4da62f14ae8dd5f491c
e0131ccd700e6bbbba2ded177396e9a7d8f99fc7342f3139dfad8c10544d351dd54e3e4775fe0c
9313b8fa98ff004feb2d732aa88381c9039af2d3baa6d3aa21a996d5506514d298a50e696b98ef
410547b464cfe37309e4a3343ffc177c2a290fe2edba8a3ed23ee68941fe64fbd6fc56eeaede53
9d87e1cf35837def6b185ee21ad68c927b97274f6a7b56a9a396aed3399a08e43197f01682e1e8
cf5516ddfd45258f45c949485df285d1ff0014a76b7ce3c5e711ece5ed0b97a81d26d76cd47494
0436bb81b0768d3fe35fe7387d6ac6349350ee7696d3754692aebccb563ac14cc32b878e3a2f3b
16eae94bfd5b6921ae7d3d53b9362aa8cc44f867aaf9dbfd056dd3363a7925a68a7ba4ec6c9535
523789ee7119c027a05b1adf41daf55596761a58a2af634ba9ea63606bdaf1cc731cd0496e370a
6b5dbaa2beadfc14f4f199247633803af25e767bbd1df2d505ca8253252cede28de5a4647814ac
b1ea3a9d45b117a35ef2faca3a69a96579392ee11c89f6296ed37e6c6c9fb9fbca0945d6e74966
b5d45c6ba4ece9a9d9c723b19c0f05cea8d5f66a5d2ccd492d496dadec6bdb2f01e84e072eab9f
b9df9b5bf7d14fda97f7ff00f063a33ffeb43fc6827b26e5e986dde8ad51573a7acac2d11c7146
5dc3c5d388f7755301d141f6db475aac5a52dd3b296292b6785934b52f6073dce233d4f3185384
1c5bd6a9b4582badf4572a9ec66b839cda71c248716e3393dde70eab46c5aff4fea5bccf6bb4d5
3ea65819c6f7b58783ae393bbd2ff7c6da2f1aa3425b8c8e8db53515119734e0804c394c49e92d
1a1f4a56555be820a78a8e9dcf1c0c00bb03964f53cd067526b9d3da4c305dabdb1caff361602f
91dff28e6b896dde2d1f71ab6d33aae7a491e70cf8dc2e8c3bda792826dbdc3483a39b53eacbdd
04f7ead90bf86a9e1c606e79000f4535bf5f76cb525ba4a2b8dded1231edc078700f67ac1ea103
09b231ec0e6b839a46411d0a825db77f48d9ee5250cd573cd244712be9e0748c61f590a37b457a
a9adb66a2d30db88adf930f0d15587643e377106f3f40c0f7ae4ed7dff004e69db6d5e97d514f1
d0dd4ccf13baae3f26707fde3f7a075daee94578b7c35f4150c9e9a61c4c9187915c3d49b81a6f
4ac822b9dc00a877482269924fec85c81476fdb0db7ba54da2a25a8a78daea884c8f0e01cec018
23bb385cfdacd194b1d8e1d477689b5978b90eddf3ce38cb01e8067a20e95ab783485d2ad94a6b
26a495e70d1570ba30ef69e4a74e9a310997881606f1710e7cbaae26a4d1f66d4f6c968ee1450b
8b9a43250c01f19ee20f5507da9bad73ac7a834ddca574d536591f036471c9319071f62060e9ed
476cd516df942d3399a9b8cc7c45a5bcc75e45746a278e9a9e49e5388e3697b8fa00192965b07f
9b9fff00b25fb42615f3e60b97d165fe0283468357d9ae5a665d434d525f6d89af73e5e02301bd
79755c5acdd9d23474b4931b83a575580618a28cb9e4138e63bbdaa15a1ffc1bae7fb9abfb4aea
ecbe8fb55368ba4bc4f490d4575582f32cad0e2c683801b9e881995f72a3b551beaebea63a7a76
0cba491d80140e5defd1b1cc58c9eb658c1c19a2a57160f6ae1dd699db8fbb95161ac91ff21d8a
36be680388134871d7de9ad4f68b752d20a582869a3800c766d8806e3c106b58b52d9f52d27c6a
d35d15547dfc279b7c4750b7eb2b69a82964aaab9d90c118cbe479c003c541dbb6ccb5eb88750e
9eab6dba178c5651b59f8b987a80e8a21b9377a2beee450697bbdd194161a58fe3157c5270099d
dcd3ff00be941289f7b346c352628ea2ae7634e0cd0d2b9cc1ed530b0ea6b3ea5a3f8d5a2ba3a9
8c72770f569f58ea14728f576dc5051368e9aeb658a980c08dbc38c7b92df50deb4d695d6b6ad4
7a3aed48e8aa6a04171a2a67f92e61fd2e11cbd3edc2072ea5d5d66d2544caabbd5764d79e18d8
d69739e7d40732b9fa5f71b4eeada97d2dbea24655b1bc4609e331bc8f4807aa836e7bc59371b4
f6a3bbd1c95762822313c359c6239327ca23a778f72945150691d67a86dfaa2cf706bab2841c0a
67069703dcf6f5413d595808419421080421080421080421080421080421080421080421080421
080421080421080421080421080421080421080421080582b2b08231aba8c4b47da0665c3d4964
e690e3918c14e9b946d9291e1c33c92a6e110f8d3c3598e6b0f269f7b87a8e89c899c738e4b7d2
150cb75cee96aa9708e6edcbd9c5cb8873e8a4d76b953daedf3544f201869e16f7b8f700b377d2
76fbc624a98dcc99a394b19e172e752689b752d409a67d4553d9e6f6efe203d8ab99a5a7ba65b7
1c7231d271522263d4efc7f0e0e91b90b7692acaf7c2f91ac9cb8b59d71dff006aeed5d259f50d
9456d4451703a2e3ed790730e3a67d4574adf63a3b6d24b4b0b0ba295c5cf6bf9e73d571a4d096
c2f21b254b2171c985b21e14eeaccefc22b833d31463d45a35ad4ff6e2dba8eaaf5b7b3d365d23
d92130171e6e0d39c2e9e9da7d3b77b6c59b7d1b6aa3686cb1ba31c41c3bfdaa574749051d3320
8236c71b061ad03a2e3dcb485bae5506a0b248273ccc90bb8492a7e589898f088e25f1f6da3569
88d4c4fbfda5ad75a4d3167a47cf516ea22e00f047d98cbcfa30ba5a798c36b8e565ba1a033794
618863c095a345a32db4750da897b5aa95bd0ceee2c7b14cad142eabab6340c8c85cccc4c76d67
6b6949c73396f115888f11feca4fa369e56c85ee6e02d0de7b24d5ba562bcd1022becf30a989c3
a86fe97d80fb14fe828e3a481ad6b4038e6b85b877d834f687b9d6ced6bf311898c774739c3002
df8e9db5d3c973791f3e69bc16fa6ae677577328aece6385b2c748c7863872edddff00de7fb214
db7674f54ea3d075505134baaa9dc2a2368eae2dee1ec5e5b41a5ff06742d376ace1abadfee89b
9608cf41ec0a7f8e5d158c888682d696fd5560a67c533195d13032a69dc70f63c0c1e5e8e4b6f5
8eb1b7692b24f59553b3b7e1221801cbe47e39003c572aff00b51a72fb5ceae6c735beb1dcdd35
149d9971f580bc6cdb43a72d75ccaea9f8d5cea5872c7d74a640d3ea05071344691ae87662e747
3b0b2baeb14d388c8e60b9be48fb3deb7b65b505256e87a6b5195b1d7d017452c0e3870e670709
98072504d41b51a76fb7275c9a2a682b5fcdf35148632e3e92020d0de8d4f476ad095b6e32b5d5
b5ececa289a72ec67ca2477001472fff00e0c549f4687f8d4b6836834d51d2d5c730a9ad9eaa33
13ea6a652f91ad3faa4f45dcaad1569abd1b1e9695b29b6c6c6b000ff2b0d391cd06ee95fea95a
3e8717f085d85af434915050c147082228236c6cc9e7803016c2052eeb7e70b6e7e993fdb0a62e
a3b50bde9bb8db3201a981d1827a648e5f5ad6bde94b6dfeeb69b8d6b6433dae47494e5aec005d
c39cfa7cd0bb984090db0b6e8eacb6bf4fea0b0db19a82df23a299b550b78e519387027aa9bde3
4b6ddd86df2575cac3668206349cba9d993ea031ccaded53b79a7f56c8da8afa574756ce4da9a7
77049ef1d570a8765f4ec154c9ebe7afba701cb23ac9cbd83d883c7435ce822d2975d5345a3e9e
d703438c31d330364a989bcf2790f67b575697f05374349c772aeb7d3c913da78bb4e1ed203dfe
58e614d590431c020644c6c4d6f08606e001e8c25d56ecae9caaac966a79ebe8619ddc52d3534e
5b1bbd8821fa06d353a8b6eb5969ba7a97cf411d53e2b74af3c881938cfa3934fb4a98ed46afa5
afd374f63ac91b4d76b6b7b0969e5f25c71c811e9536b158adda72d515b6d94ed829a3e8d1d49e
f24f795c1d4db6ba7754548aba9a77d3d68ff29a57766f3e247541dcbeea2b669cb6cb5f73aa64
3146d2704f377a80ef297fb476caaaca4d41a8eb62742ebe5439f1b1c3988f9e0fd6b76836634e
c156ca8b84f5f742c39632b272f68f6262471b228db1c6c0d63461ad68c003d01028763eeb0db2
df73d295ef6c173a2ac79ec9e705ed3de3d3cc1fa94d770753d169cd237096795bf189a07c5045
9cb9ef7020607b578ea9db4d3faaeb05755452d3d7018f8cd2bf81e7c48eab42d1b45a7edb52ea
aa992b2e3505a58c92b2632706411900f7f34113d0dfe0db72fdcd5fda54db697f36166fdd1fb4
ae9db7455a6d5a466d334cd945be66bdae05f9761fd79ae9d8acb49a7acf05ae84385340de1607
1c9c205756d60dbcde3abba5c5a5967bfc6d6fc631e4c728c75ffde8536e0aba7a9a76cf04f1c9
0b8643d8e0411e2bc2ed67b7df285f4372a48aa699fd592373ed1e8297efd90b087914d72bbd35
313ce9e2aa21a83b2fdc7b7cfad20d356ba796e13bb9cf342e1d9c03d6541f5e5aedb63dd5a1d4
17eb6c35962b843f1799d2c61ed8641d1c73d3bbeb4cfd33a3ec9a4a94c168a26c25fe7c879bdf
e2e3cd74ee56ca2bbd0c94570a68ea29a4187c723720a08dd3687d05594eda8a6b0596685c3883
d90b08c7a72a1b5add1726b4a1d3760d1f67b94ae3c559336268653333d7201e7d7ea5d497646c
02577c52e176a4a771c9a786a886297e99d1f64d274ae82d346d88bffa490f37bfc4a0e6cfacad
cfd72fd1f5f465ae7c02464b37098e51faa01ebde97dac2c96bd27b99a4ea74b31b495b5b57c15
5494e70c3165b93c2390182ef5724cad59a12cdac5b09b8c5232a60fe8aa6077048cf6ad1d33b6
364d337237263eaababf8785b51592191cc1feee7a209a8e4165602ca010842010842010842010
842010842010842010842010842010842010842010842010842010842010842010842010842016
165083e1ec0f6907a2e4cba7692590bcb064aec21733589f2b2996f8ff004ce912acd2ad7bff00
17d1699d1a7ae54e708c2e270d25b2bd4f9158d44a0ff81bebfa979bf45bdc460e029e611851f0
53f0ea3aaf263da05f818f6b873e5e0b7d9a46310f3c7178297611848c148f4e6dd53916f6820d
14e74849772f05ddb469e8edcee2e44aef6118535c55afdc438cbd433e5af6da7e98ee5cbbe69b
b5ea482182ed4a2a628a412358e71038874271d5755655ac4f963431a1a00000c0017d21080421
080421080421080421080421080421080421080421080421080421080421080421080421080421
080421080421083fffd9
}\par
\plain\f1\fs32\b A load balancing module for the Apache web server.\par
\plain\f1\par
\plain\f1\b Introduction\par
\plain\f0\fs20 mod_backhand is a dynamically loadable module for the 
Apache web server developed at The Center for Networks and Distributed 
Systems (CNDS) at The Johns Hopkins University.  This module aims to 
seamlessly allow for load balancing within a cluster of machines.  This 
paper will discuss the concepts, implementations, 
advantages/disadvantages, practical applications and future directions.\par
\plain\f0\fs20\tab mod_backhand is a part of the Backhand project 
initiated at CNDS. The purpose of the Backhand project is to develop 
tools for effective resource management and utilization. The purpose of 
mod_backhand, specifically, is to provide the infrastructure to 
reallocate HTTP requests to any machine within a cluster and the 
framework for effective and flexible decision making.\par
\plain\f0\fs20\tab The concept behind mod_backhand is the amalgamation 
of several important deviations from "standard" practice.  Many network 
appliances used for balancing web clusters have their foundations in 
the networking world.  This leads to a design drawn in the image of a 
router.  This approach was purposely avoided in an attempt to avoid 
bottlenecks and single points of failure.  The approach we use allows 
for maximum utilization of a network's egress points and survives link 
failures extremely well.  The flexibility of the implementation 
provides a tool that can be used to build both a single and a multiple 
entry point cluster.\par
\plain\f0\fs20\tab The Backhand project was designed to tackle all 
aspects of resource allocation and management.  This was done for two 
reasons.  First, the issues that must be tackled are far out of the 
scope of an Apache module.  Second, it allows for intelligent 
separation of concepts and functionality.  mod_backhand, in its current 
form, attempts to solve resource allocation and management issues 
within a cluster of machines on a relatively low latency, 
high-throughput network.\par
\plain\f0\fs20\tab The problems involved in finding the best web server 
or cluster for a specific client are better tackled at a lower level.  
Specific approaches including optimizing algorithms based on DNS and IP 
routing are not in the scope of mod_backhand, but fit well in the more 
general Backhand project.\par
\plain\f0\fs20\par
\plain\f1\b Problem\par
\plain\f0\fs20 There many complicated problems involved in load 
balancing a web cluster.  Just a few of the major issues include: 
administration complications, regular file consistency amongst servers, 
algorithms for balancing load and the actual mechanism for balancing 
load.  mod_backhand does not attempt to deal with information 
consistency of regular filesystems or databases.  They are out of the 
scope of this project.  The issues that mod_backhand does attempt to 
cope with a those of mechanics and algorithms.\par
\plain\f0\fs20\tab The first stepping stone of any load balancing system 
is its architecture.  There are several to choose from, but mot contain 
common components.  These components are external to web serving itself 
as they lie on the networking level.\par
\plain\f0\fs20\tab How is a client (web browser) delivered to the 
correct web server in the first place?  The answer, of course, is DNS.  
It has a record that looks something like "www 3600 IN A 10.0.1.5", 
meaning that host www has the IP address 10.0.1.5, but this information 
can only be cached for 3600 seconds (1 hour.)  After this time period, 
clients and caching servers alike are to request this information from 
an authoritative source in case it has changed.\par
\plain\f0\fs20\tab DNS is a fairly flexible architecture.  It allows for 
multiple hosts to point at the same IP address and it allows for a 
single host to point at multiple IP addresses.  If the DNS 
administrator provides multiple "A" records for a host like www (like 
"3600 IN A 10.0.1.5" and "3600 IN A 10.0.1.6"), then all IP addresses 
will be responded to any DNS queries.  Due to the implementation of 
DNS, this will cause some clients to resolve www to the IP 10.0.15 and 
all others 10.0.1.6.  This scheme of assigning multiple IP addresses to 
a host name to naively distribute requests amongst a set of servers is 
known as DNS round robin.\par
\plain\f0\fs20\tab Will each server recieve an even number of incoming 
requests?  Over some large time period, perhaps.  Consider a two 
machine web cluster, where one machine receives requests during the the 
first 30 minutes of every hour and the second during the second 30 
minutes of every hour.  The average resource utilization on the 
machines is equal when looking at an average day and likewise when 
looking at an average hour.  Yet, the servers are unbalanced.\par
\plain\f0\fs20\tab Another approach to distributing incoming requests 
across multiple physical machines is known as proxying.  The proxing 
can either be done on layer 4 (as mod_proxy does) or on layer 3 (as 
BIG/ip and other like products do).  Proxying involves putting a 
machine between the clients and the actual servers.  The clients will 
attempt to contact the server via the proxy and the incoming 
connections will be dynamically assigned to the "best" server.  On 
layer 3, the dynamic assignments must be for the entire TCP/IP session, 
and the allocation decisison is not based of the actual request (URL or 
HTTP headers).  On layer 4, the procy can now reallocate requests on a 
per request basis and is able to incorporate the HTTP headers and URL 
requested into the decision.  On layer 4, the request must be processed 
at the proxy and then again at the actual server increasing overhead 
dramatically.\par
\plain\f0\fs20\tab Proxying does not suffer the same issues as the DNS 
round robin approach with respect to poor distribution of requests. 
However, it does introduce a single point of failure.  If the proxy 
fails, there will be many inaccessible servers.\par
\plain\f0\fs20 \tab Neither DNS nor proxying will solve the problem of 
allocation of requests to a machine that is too busy to handle them.  
They do not use information about resources within the cluster to make 
their decisions.  In contrast, mod_backhand is able to gather the 
necessary information and utilize it in an intelligent way when 
distributing the requests.\par
\plain\f0\fs20\par
\plain\f1\b Solution\par
\plain\f0\fs20 mod_backhand attempts to compensate for the weaknesses in 
earlier architectures through simple, selective combination.  On top of 
previous architecures a flexible framework for decision making is used 
to intelligently reallocate requests.\par
\plain\f0\fs20\tab Both DNS round robin and the proxying architecture 
have very specifc drawbacks.  However, their drawbacks are such that 
they can be avoided is combined correctly.  If each machine in the 
cluster had the ability to proxy requests to any other machine in the 
cluster, then the load can be distributed naively across those machines 
with DNS round robin and the single point of failure disappears.  Both 
DNS and proxying do not provide a good framework for intelligent 
decision making.  As they both operate on TCP sessions, the session 
will be assigned to a server without knowing about the future requests 
that may be asked across it.\par
\plain\f0\fs20\tab This approach sidesteps the two major drawbacks in 
DNS round robin and proxying, but it is not a perfect solution.  In 
fact, due to the inequity of resource requirements amongst requests, 
this solution is merely the architectural framework for a correct 
solution.  We must decide where the requests are to be reallocated more 
intelligently.  We need to use information about the request, the 
headers and the available resources in the clutser.\par
\plain\f0\fs20\tab The serious issue that mod_backhand attempts to 
tackle is a resource allocation problem.  These problems have been 
worked by too many researchers to name names.  The fact that remains is 
that no web load balancing infrastructure uses resource utilization 
information to make decisions.\par
\plain\f0\fs20\tab When looking at the overall concept of web server, we 
see that by servicing a request, we dedicate resources on the network 
and on the server that responds.  Once the transaction is complete, 
those resource become available.  The more resources a server has, the 
more quickly it can respond to any given request.  So, assigning 
requests to machines on the basis of information other than resource 
utilization information seems a bit confused.\par
\plain\f0\fs20\tab Knowing the request and resources of every machine in 
a cluster, which machine is "best" to service a request?  This is a 
open area of research, and we are still investigating various 
algorithms.  We realized that mod_backhand would be the first web 
clutser load balancing solution to use resource utilization information 
in the decision making process, so we accounted for this in the 
decision making framework.  This framework is vital for the ongoing 
research on online resource allocation of HTTP requests.\par
\plain\f0\fs20\tab As discussed before, average utilization can be 
deceiving if the time period for average is too long.  How long is too 
long?  It is directly related to the length of time required to satisfy 
a request.  If requests commonly take a day to satisfy, measuring the 
resource utilization every 12 hours should be sufficient.  The larger 
the averaging period for this information is, the larger the error will 
be.\par
\plain\f0\fs20\tab Is load what we want to be balancing?  Let's, for 
argument's sake, assume a web request takes 30ms.  This would mean that 
our resource utilization information (load in this case) would have to 
be a 15ms snapshot or 30 ms rolling average.  This is shorter than the 
time slice for process scheduling on most machines.  System load on 
UNIX machines currently has a 1 minute rolling average.  We see the 
problem immediately.  We need resource utilization information 
available on the same time scale as our request times.  Resource 
allocation techniques for scheduling jobs on clustered servers has been 
researched for many years.  Though the same theory applies directly to 
the problem at hand, the short job length makes previous practical 
solutions inapplicable. In particular, handling requests as dynamically 
migratable entities is not appealing due to the short duration of the 
requests. On the other hand, the ability of mod_backhand to analyze the 
requests before they execute seem to allow a better use of profiling 
techniques. This, among other things, is an on going research.\par
\plain\f0\fs20\par
\plain\f1\b Implementation\par
\plain\f0\fs20 The implementation of mod_backhand can easily be split 
into several components:\par
\pard\li360\tx360\plain\f3\fs20 \'b7\tab\f0 The resource information 
manager (RIM),\par
\plain\f3\fs20 \'b7\tab\f0 The resource maintenance assistant (RMA),\par
\plain\f3\fs20 \'b7\tab\f0 The decision maker (DM),\par
\plain\f3\fs20 \'b7\tab\f0 The diagnostic tool (DT),\par
\plain\f3\fs20 \'b7\tab\f0 The internal proxy.\par
\pard\plain\f0\fs20 Each of the components interacts closely with the 
others to provide a framework for informed resource allocation 
decisions.  They will each be discussed in turn with an example 
configuration directive if applicable.\par
\plain\f0\fs20\par
\plain\f1\fs20\b The resource information manager (RIM)\par
\plain\f0\fs20 The resource information manager is responsible for 
acquiring resource utilization information from the local web server, 
multicasting that information to the cluster and collecting resource 
utilization information from other machines in the cluster.\par
\fi720\plain\f0\fs20 The RIM must collect local resource utilization in 
a manner that is architecture and platform dependant, so mod_backhand 
has a specific section of code that is very system dependant; 
therefore, porting to new architectures is not always trivial.  All 
resource information is held in an attached shared memory segment 
created during Apache's initialization phases.  All one time 
(unchanging) information is calculated at this time and stored in the 
shared memory segment.  Current one time information includes the 
hostname, service, number of CPUs, total physical memory and the speed 
of the machine (calculated by forked, tight floating point loops).  The 
speed of the machine is called the arriba and is stored in a file in 
order to speed restarts.  The web server is blocked completely during 
start up while the arriba is calculated.\par
\plain\f0\fs20 The RIM uses either IP broadcast or IP multicast to share 
resource utilization information.  Multiple multicast and/or broadcast 
addresses can be used for information multicasting.  The default 
multicast interval is one second and can be changed at compile time.  
The RIM is also in charge of trivial access control during the 
acceptance of information.  This is done with simple accept clauses 
which are checked against the sender IP of  each packet.\par
\plain\f0\fs20\par

{\trowd\trgaph108\trleft10\trrh2087
\trbrdrt\brdrs\brdrhair\brdrw10
\trbrdrl\brdrs\brdrhair\brdrw10
\trbrdrr\brdrs\brdrhair\brdrw10
\trbrdrb\brdrs\brdrhair\brdrw10
\trbrdrv\brdrs\brdrhair\brdrw10
\trbrdrh\brdrs\brdrhair\brdrw10
\clbrdrt\brdrs\brdrhair\brdrw10
\clbrdrl\brdrs\brdrhair\brdrw10
\clbrdrr\brdrs\brdrhair\brdrw10
\clbrdrb\brdrs\brdrhair\brdrw10
\cellx8010
\intbl\fi0\plain\f0\fs20 Directive for broadcasting on the 
10.0.5.0/24 on port 4445:\par
\plain\f2\fs16 MulticastStats 10.0.5.255:4445\par
\plain\f0\fs20 or the same but explicitly binding to the 10.0.5.10 
interface\par
\plain\f2\fs16 MulticastStats 10.0.5.10 10.0.5.255:4445\par
\plain\f0\fs20\par
\plain\f0\fs20 Directive for multicasting to 240.220.221.20 port 4445 
with a time to live of 3 hops.\par
\plain\f2\fs16 MulticastStats 240.220.221.20:4445,3\par
\plain\f0\fs20 or the same but explicitly binding to the 10.0.5.10 
interface\par
\plain\f2\fs16 MulticastStats 10.0.5.10 240.220.221.20:4445,3\par
\plain\f0\fs20\par
\plain\f0\fs20 Directive for accepting statistics from 10.0.5.1:\par
\plain\f2\fs16 AcceptStats 10.0.5.1\par
\plain\f0\fs20\par
\plain\f0\fs20 Directive for accepting statistics from all IPs beginning 
with 10.0:\par
\plain\f2\fs16 AcceptStats 10.0.0.0/16\cell\row
}
\fi0\plain\f0\fs20\par
\plain\f1\fs20\b The resource maintenance assistant (RMA)\par
\plain\f0\fs20 The resource maintenance assistant provides mostly 
cleanup and pre-allocation services for expensive operations that 
should not be done on demand.  Its purpose is similar to the apache 
pre-forking ability.  The RMA maintains a pool of existing connections 
to other servers within the cluster and manages their wellbeing.\par
\plain\f0\fs20\tab The time required to allocate a system socket and 
connect to another web server can be quite substantial and requires a 
multitude of resources (systems calls and TCP/IP negotiation on both 
the local machine and the remote machine).  This is done in an 
asynchronous manner, to avoid unnecessary blocking.  The RMA maintains 
a pool of already established connections, building them and tearing 
them down as necessary.  An individual Apache process, after deciding 
to reallocate an incoming request to machine X, will ask the RMA for an 
already established connection to server X.\par
\plain\f0\fs20\tab The RMA and the Apache processes (children) 
communicate via UNIX domain sockets (AF_UNIX).  These files are created 
in a directory specified at run time by the UnixSocketDir directive.  
The RMA and children communicate over these sockets to request 
connections to other servers within the clutser and to hand open file 
descriptors (attached to open BSD sockets with established TCP/IP 
sessions) back and forth.  The connections that the RMA manages to 
other servers and kept alive as long as possible (via header rewriting 
discussed later).\par
\plain\f0\fs20\par
\plain\f1\fs20\b The decision maker (DM)\par
\plain\f0\fs20 The decision maker is simply a flexible (configurable) 
set function: dm(SS, R) -> server; where SS is the resource utilization 
information for the cluster and R is specific information about the 
request being made.  In order to provide maximum flexibility, 
mod_backhand can dynamically load decision making functions at run time.\par
\plain\f0\fs20\tab The decision making framework is designed around the 
concept of candidacy functions.  Multiple functions can be provided and 
the DM will execute each in order to arrive at a decision.  The 
function can reorder, narrow, or even expand the set of candidates for 
reallocation.  The function is called with an array of integers, a 
parameter and a request line.  The array has a size equal to the 
maximum number (n) of servers in a cluster (compile time value) and 
contains an ordered set of candidates.  The process starts with an 
array enumerated from 0 to n.  Each candidacy function can then 
reorder, remove or add candidates to the array.  This array is called 
the candidacy set.  At the end of the candidacy function processing, we 
choose the first element in the candidacy set.\par
\plain\f0\fs20\tab As little research has been done in the area of 
per-request resource allocation algorithms, we required simple building 
blocks that allow the easy construction of more complicated decision 
making algorithms.  The first and most obvious building block is one 
that eliminates servers that are no longer participating in the cluster 
(downed or crashed).  Another convenient building block performs a 
randomization of a set of servers.  Two more blocks reorder a set of 
servers based on system load and CPU utilization.  These blocks allow 
algorithms to equalize both load and CPU utilization.\par
\fi720\plain\f0\fs20 As has been discussed, using system load has 
sampling problems.  Requests will be continually assigned to the same 
machine until the load slowly rises above the other servers in the 
cluster.  Unfortunately, system load slowly follows resource 
utilization (because it is a rolling minute average) and, on some 
systems, it can take up to five seconds to change at all.  This means 
that an algorithm balancing strictly based on load, we will overload 
each server in a round robin fashion.\par
\plain\f0\fs20 A simple way to compensate for this problem is to have 
each server consider only a window of the available servers.  This 
window was proposed to contain only a logarithm of the number actually 
available.  Thus, we have a building block that will remove all but a 
base 2 logarithm of the available server set.  We don't wish to have a 
server consistently look at the same set of servers, so by combining 
this with the randomizer block, we can select a random window of 
servers from a given set.\par
\plain\f0\fs20 The last building block we want is based of a more 
theoretically based allocation approach.  This approached is based of 
the supply and demand principles of economics.  It assigns an 
exponentially increasing cost to each resource on a machine.  This 
block will reorder a set of servers based on the calculated cost of 
allocating the necessary resources to satisfy a request.  Determination 
of those resources, their costs and adapting this approach to 
short-term jobs is still in the research stage.\par
\fi360\plain\f0\fs20 These blocks are implemented as built-in candidacy 
functions and are provided to allow the creation of customized 
load-balancing algorithms.  They are as follows, in the order 
introduced above:\par
\pard\fi-360\li720\tx720\plain\f3\fs20 \'b7\tab\f0 byAge [ #seconds ] 
(removes all servers with resource information older than #seconds from 
the candidacy set.  5 is used if #seconds is not specified)\par
\plain\f3\fs20 \'b7\tab\f0 byRandom (reorders the entire candidacy set 
not effecting its cardinality)\par
\plain\f3\fs20 \'b7\tab\f0 byLogWindow (removes all candidates except 
for the first log base 2 of cardinality of the candidacy set.\par
\plain\f3\fs20 \'b7\tab\f0 byCPU (reorders the entire candidacy set, 
placing those with the lowest CPU utilization first)\par
\plain\f3\fs20 \'b7\tab\f0 byLoad (reorders the entire candidacy set, 
placing those with the lowest one minutes average system load first)\par
\plain\f3\fs20 \'b7\tab\f0 byCost (reorders the entire candidacy set 
placing those with the lowest cost first.  Cost is based on the 
cost-benefit framework as described in "A Cost-Benefit Framework for 
Online Management of a Metacomputing System", by Amir, Awerbuch and 
Borgstrom.)\par
\pard\plain\f0\fs20\par
\plain\f0\fs20 If mod_backhand changes, every server in the cluster 
needs to be updated and restarted.  This is not effective or even 
feasible in large clusters.  The ability to create a candidacy function 
outside of mod_backhand and dynamically load it in at run time 
alleviates the need to restart servers.  An attempt was made to make 
this as straight forward as possible by introducing an API with a 
single function prototype. It simply requires writing a function and 
compiling it as a dynamically shared object.  A sample byHostname is 
provided with the mod_backhand distribution.  The function prototype is 
as follows:\par
\plain\f0\fs20\par
\plain\f2\fs16 int function_name(request_rec *r, int *servers, int *n, 
char *arg);\par
\plain\f0\fs20\par
\plain\f0\fs20 r is the request structure for decision making purposes.  
servers is the array or candidates and n is a pointer the number of 
viable candidates. The new cardinality of the candidacy set (servers) 
should be placed in *n as well as returned.  During the decision 
making, there is serverstat *serverstats variable (global) that 
contains all of the resource utilization information about each machine 
in the cluster.  The definition of the serverstats structure is as 
follows:\par
\plain\f0\fs20\par

{\trowd\trgaph108\trleft-17\trrh3293
\trbrdrt\brdrs\brdrhair\brdrw10
\trbrdrl\brdrs\brdrhair\brdrw10
\trbrdrr\brdrs\brdrhair\brdrw10
\trbrdrb\brdrs\brdrhair\brdrw10
\trbrdrv\brdrs\brdrhair\brdrw10
\trbrdrh\brdrs\brdrhair\brdrw10
\clbrdrt\brdrs\brdrhair\brdrw10
\clbrdrl\brdrs\brdrhair\brdrw10
\clbrdrr\brdrs\brdrhair\brdrw10
\clbrdrb\brdrs\brdrhair\brdrw10
\cellx7977
\intbl\plain\f2\fs16 typedef struct \{\par
\plain\f2\fs16\par
\plain\f2\fs16   /* General information concerning the server and this 
structure */\par
\plain\f2\fs16   char hostname[40]; /* or truncated hostname as the case 
may be */\par
\plain\f2\fs16   time_t mtime;      /* last modification of this stat 
structure */\par
\plain\f2\fs16   struct sockaddr_in contact; /* the associated inet addr 
+ port */\par
\plain\f2\fs16\par
\plain\f2\fs16   /* Actual statistics for decision making */\par
\plain\f2\fs16   int arriba;   /* How fast is THIS machine */\par
\plain\f2\fs16   int aservers; /* Number of available servers */\par
\plain\f2\fs16   int nservers; /* Number of running servers */\par
\plain\f2\fs16   int load;   /* load times 1000 (keep floats off 
network) */\par
\plain\f2\fs16   int load_hwm; /* The supremim integral power of 2 of 
the load seen thus far */\par
\plain\f2\fs16   int cpu;    /* cpu idle time 1000 */\par
\plain\f2\fs16   int ncpu;   /* number of CPUs (load doesn't mean too 
much otherwise) */\par
\plain\f2\fs16   int tmem;   /* total memory installed (in bytes) */\par
\plain\f2\fs16   int amem;   /* available memory */\par
\plain\f2\fs16 \} serverstat;\cell\row
}
\plain\f0\fs16\par

{\trowd\trgaph108\trleft-30\trrh1968
\trbrdrt\brdrs\brdrhair\brdrw10
\trbrdrl\brdrs\brdrhair\brdrw10
\trbrdrr\brdrs\brdrhair\brdrw10
\trbrdrb\brdrs\brdrhair\brdrw10
\trbrdrv\brdrs\brdrhair\brdrw10
\trbrdrh\brdrs\brdrhair\brdrw10
\clbrdrt\brdrs\brdrhair\brdrw10
\clbrdrl\brdrs\brdrhair\brdrw10
\clbrdrr\brdrs\brdrhair\brdrw10
\clbrdrb\brdrs\brdrhair\brdrw10
\cellx8010
\intbl\plain\f0\fs20 Directive for choosing the least loaded server with 
fresh information:\par
\plain\f2\fs16 Backhand byAge\par
\plain\f2\fs16 Backhand byLoad\par
\plain\f0\fs20\par
\plain\f0\fs20 Directive for choosing the least loaded server in a 
random log sized window of servers with names that match the regex 
/alpha/ and have information recent to within 2 seconds:\par
\plain\f2\fs16 Backhand byAge 2\par
\plain\f2\fs16 BackhandFromSO libexec/byHostname.so byHostname alpha\par
\plain\f2\fs16 Backhand byRandom\par
\plain\f2\fs16 Backhand byLogWindow\par
\plain\f2\fs16 Backhand byLoad\cell\row
}
\plain\f0\fs20\par
\plain\f1\fs20\b The diagnostic tool (DT)\par
\plain\f0\fs20 The diagnostic tool provides a mechanism for convenient 
cluster resource utilization monitoring.  Its basic purpose is to 
present the information available to you (the administrator) the same 
information that is available to the DM.  As the diagnostic tool is a 
simple apache content handler, it can be used in the fashion as the 
server-status content handler provided by mod_status. It looks in the 
shared memory segment for the resource utilization information and 
outputs an easy-to-read table with the data.  One must be careful not 
to enable load balancing on that content handler (Location) or you may 
get another machine's backhand-handler.  It also provides links to the 
Backhand project and CNDS to make looking for related resources more 
convenient.\par
\plain\f0\fs20\par
\plain\f1\fs20\b The internal proxy\par
\plain\f0\fs20 The internal proxy handles the dirty work of redirecting 
requests.  It performs in a very similar fashion to mod_proxy.  If 
mod_backhand  finds that another server is a better candidate than 
itself to serve the request, the proxy will contact the RMA and request 
and open channel.  It will then make a request for the same URI over 
this channel feeding the response back to the client.  It does however 
make optimization in stride.\par
\fi720\plain\f0\fs20 One of the more expensive operations in HTTP is 
the constant building and tearing down of TCP/IP sessions.  This 
requires quite a bit of effort from both parties involved.  The RMA, as 
described above, maintains established connections to the server; 
however, that does little good if the HTTP protocol terminates and the 
session completed.  Many clients make requests in a closed connection 
manner.  As a web server you have to respect this as it is legal HTTP.  
However, as we are guaranteed that mod_backhand will be the only 
process talking over the RMA established sessions, certain 
optimizations can be made.\par
\fi0\plain\f0\fs20\tab When the client requests a specific URL from 
server X and we find that we are going to proxy it to server Y, we can 
augment the headers to maintain different semantics on the two 
different sessions (client::X and X::Y).  The client can either request 
a document from X in a manner that will maintain the sessions after the 
response (called keepalive) or in a manner that will terminate the 
connection after that response (called close).  These session semantics 
are defined by the HTTP headers that are transmitted to and from the 
server.  X will maintain a legal HTTP connection to the client, however 
when it proxies the request to Y it will modify the headers to as to 
force an HTTP session with keepalive semantics.\par
\plain\f0\fs20\tab Other header modifications are made to provide hints 
to server Y that the request has already been proxied once.  The header 
is the HTTP_BACKHAND_PROXIED header and is processed in the 
post_read_request phase of the request processing.  This header is 
ignored if the requests remote IP is not in the AcceptStats access 
control list.  This effectively eliminates outsiders from defeating 
mod_backhand.\par
\plain\f0\fs20\tab A particular issue to be dealt with is IP based 
authentication that is commonly used by webmasters to control viewing 
portions of their sites.  mod_backhand will respect this initially, but 
the proxied request will be from X not the client.  This is not the 
desired behavior, so the HTTP_BACKHAND_PROXIED header serves another 
purpose.  While the fact that it exists denotes that the request is a 
proxied one, the value of this header holds the "real" clients IP 
address.  During the post_read_request phase, mod_backhand will switch 
remote_ip addresses in the headers, environment variables and internal 
Apache structures required for transparent functionality.\par
\plain\f0\fs20\par
\plain\f1\b Advantages/Disadvantages\par
\plain\f0\fs20 The advantages and disadvantages of using mod_backhand 
are difficult to quantify without directly comparing it to another 
scenario.  We will attempt to discuss where it sits in the field of web 
clustering solutions by comparing it to several prominent load 
balancing set ups.  The easiest way to begin a comparative analysis is 
to describe the advantages of other products and/or methods.\par
\plain\f0\fs20\tab The most common method of balancing sites on the 
Internet today is the use of multiple A entries in a DNS record.  This 
method is commonly called DNS round robin.  This provide a na\'efve 
distribution of incoming clients over a set of servers.  However, other 
than providing a simplistic method of distributing incoming requests, 
it only has drawbacks.\par
\plain\f0\fs20\tab Due to the nature of DNS, caching name servers, and 
the variety of DNS servers that are not RFC compliant, the time to live 
attribute on a DNS record often is not obeyed.  Though this removes a 
single point of failure found in proxied set ups, this makes updating 
the DNS to take a downed server out of rotation extremely ineffective.  
Also, due to the nature of caching and the uneven utilization of name 
servers across the Internet make for poor load balancing.  Resources 
within the cluster are not utilized effectively.\par
\plain\f0\fs20\tab There exist two types of proxied set ups, one is on 
layer 4 and the other is on layer 3 of the OSI network model.  Both 
suffer from the single point of failure problem as well as network 
topology restrictions.  The layer 4 design functions very similarly to 
mod_proxy combined with internal DNS round robin.  It has the single 
point of failure problem that all proxy based solutions have.  It does 
have one main advantage; as it is processing requests on layer four, it 
is privy to the actual URL and headers that are being transmitted and 
could feasibly make more intelligent decisions on where to allocate 
requests.\par
\plain\f0\fs20\tab The layer 3 model is implemented in products like 
Big/IP from F5 labs, Inc.  It doesn't process requests, but rather it 
processes TCP/IP sessions.  It redirects the TCP/IP session, most 
commonly using IP masquerading, to a backend server.  Most of the 
processing is done inside the kernel and is thus very fast.  The 
algorithms that it uses for assigning requests to servers are limited 
to the information to which it is privy.  This includes average connect 
times, average turn around times on a session and other layer 3 
statistics.  It is feasible that a machine like this could acquire and 
manage resources in the same fashion as mod_backhand and use that 
information in the decision making process.  As it operates on layer 3, 
it is very difficult, though not impossible, to extract the layer 4 
information necessary to make decisions based of the request itself.  
The concept of IP masquerading for multiple machines and attempting to 
allocate TCP/IP sessions intelligently across them is an excellent 
one.  However, the more complicated it becomes (by attempting to 
operate outside its layer), the more difficult it become to adapt to 
new services.\par
\plain\f0\fs20\tab The proxied approach does provide the ability to 
easily down a production server without the worry of a service 
interruption.  The point of failure is now in the load balancing proxy 
instead of the web servers.\par
\plain\f0\fs20\tab The mod_backhand approach is a mixture of the two and 
can be combine with any of the above solutions to solve specific 
problems.  One of the major advantages of mod_backhand is that no 
dedicated proxying hardware is required to balance your cluster.  Now, 
if you are currently using a server to balance a cluster in a proxy 
configuration, you can now use its resources to actually service HTTP 
requests.\par
\plain\f0\fs20\tab The main advantage over a proxied approach is that 
all of you hosts can be accessible from the Internet.  There is no 
single point of failure (other than your connectivity itself) sitting 
between your cluster and your clients.  If one or more host is 
accessible from the Internet, then the cluster is accessible.  The 
common method of placing more than one host in rotation is by using DNS 
round robin.  To compensate for the slowness of DNS updates/propagation 
an operation system level fault tolerance solution can be implemented.  
During the event of a downed server, another accessible server will 
make itself available from the IP address of the downed server.\par
\plain\f0\fs20\tab Using operation system level fault tolerance with 
simple DNS round robin is a good mechanism for maintaining 
availability, but it make a poor load balancing scheme even worse.  
When three servers are present and one goes down, another will assume 
its IP and its load.\par
\plain\f0\fs20\tab mod_backhand redirects requests to the best server in 
the cluster, so even under poor mechanisms of balancing incoming 
connections (like DNS round robin) mod_backhand will compensate by 
reallocating individual requests.\par
\plain\f0\fs20\tab We have not yet touched on the two main advantage 
that mod_backhand has over all other available solutions.\par
\fi-360\li720\plain\f3\fs20 \'b7\tab\f0 It requires no change in the 
current cluster configuration.  It will drop in an existing standalone 
web server as well as both DNS round robin and proxy configurations.\par
\plain\f3\fs20 \'b7\tab\f0 It is smarter!  It is has available a wealth 
of information about the request and the resources available within the 
cluster and it can redirect individual requests in a single HTTP 
session to different servers.\par
\fi0\li0\plain\f0\fs20 The combination of the those two advantages 
with the fact that it incurs no overhead when it does not reallocate 
requests, means that it works well as a full-on implementation and as a 
correctional facility for existing load balanced clusters.\par
\plain\f0\fs20\tab As an additional perk, it provides and excellent tool 
(the DT) for monitoring resource utilization within a large cluster. 
And with resource utilization information being multicasted on your 
network, other applications that could benefit from such knowledge 
could be augment to do so.\par
\plain\f0\fs20\par
\plain\f1\b Practical Applications\par
\plain\f0\fs20 This section will discuss two specific implementations of 
web clustered solutions for different web applications.  The first 
scenario we will discuss is a simple web clustering solution with a few 
PC servers and the second will be a much more elaborate, high volume 
database driven portal.\par
\plain\f0\fs20\par
\plain\f1\fs20\b Scenario 1 (The small cluster)\par
\plain\f0\fs20 Let as assume four machines exist in the current set up, 
one is sometimes for bulk emailing and another is used for processing 
logs.  The remaining two are dedicated web servers, the first is used 
as a production machine and the second is a fail-over replica of the 
first.  In the case of a downed web server, the replica will assume the 
production server's identity.\par
\plain\f0\fs20\tab The outgoing email server (or relay) sends email from 
approximately 6pm to 6am every day.  During this time, the load on that 
machine increases dramatically and it could not feasibly serve as a 
responsive web server.  The log-processing machine is used for 
processing email and web server logs.  It does this automatically every 
4 hours, but also performs many manually invoked log analysis queries.  
This machine could be feasible used as a web server in the current 
scheme; however, it would not service requests as quickly if it is 
always given an even distribution.  Putting the logs server in a DNS 
rotation scheme could be very bad when heavy log analysis is 
happening.  The backup machine could easily be put in to the rotation, 
and help the current set up.  Steps must be taken to assure network 
level fault tolerance, but any simple machine IP masquerading will work 
well.\par
\plain\f0\fs20\tab Let us now look at the implementation using 
mod_backhand as a tool for efficiently allocating resources.  We wish 
to immediately bring all available resources into the cluster, as they 
are not available to serve requests if they are not given the chance.  
We need to set up network-level fault tolerance.  mod_backhand doesn't 
handle this directly; it is instead handled by a high availability tool 
(like Linux-HA).  Next, we want to add all of our machines as A entries 
to the DNS record for the host names in question.\par
\plain\f0\fs20\tab Install the mod_backhand module into the existing 
Apache set up and you are ready to go.  Now, the only thing remaining 
is to set up the load-balancing schema.  For simplicity, we will just 
load balance the entire site sans the DT.  The rules that we wish to 
use are simple.  We want to go to a machine, so long as it is 
participating (fresh resource information), and it's load is the 
lowest.  The appropriate directives are to balance byAge and the byLoad.\par
\plain\f0\fs20\tab Now there is a fault-tolerant load balanced cluster 
servicing HTTP requests.  Downing a production server for maintenance 
and upgrades is now feasible without causing a service outage.  And any 
given machine can we used for any given purpose (log analysis and email 
relaying) as mod_backhand will compensate and allocate incoming 
requests to the server that is least loaded.\par
\plain\f0\fs20\par
\plain\f1\fs20\b Scenario 2 (The database driven portal)\par
\plain\f0\fs20 This set up is an enterprise solution to serve serious 
content (bandwidth) and a high hit rate.\par
\plain\f0\fs20\tab Let us assume that content is kept in a database and 
is processed 97% of the time by read-only queries. The other 3% of the 
requests made to system perform database updates and other read-write 
operations.  The database server is currently a larger server in 
comparison to the production web servers. There are 4 machines running 
as web servers and 2 running as dedicated email servers (outgoing 
content). Currently all database transactions are asked directly of the 
database server.  The email servers send outgoing mail on during the 
night for approximately 12 hours and the web servers maintain a system 
load of 3, while the database server maintains a load of 80.  (No, this 
is not ideal).\par
\plain\f0\fs20\tab First, we wish to bring all resources to the front 
lines.  The email servers should be added to the scenario, adding 12 
hours, each, of available resources to the set up.  We do this in a 
similar fashion to scenario 1.  Next, we wish to move the load from the 
database server to our web cluster resources.  We install the database 
server software on each web server.  We replicate the existing database 
on to the web servers making them read-only. The method of database 
replication is an orthogonal problem of information consistency; though 
in this case continually applying update/redo logs should be 
sufficient.  The web servers can now make read-only transactions to a 
locally managed database.  Finally, we drop unnecessary indexes on the 
database server as it isn't performing 97% of the queries it was before.\par
\plain\f0\fs20\tab The original database server is now far 
under-utilized and we would like to use its resources in the cluster. 
We start by insalling Apache+mod_backhand on that machine as well.  
This new web server will be a part of the cluster (though not in the 
DNS round robin set up) that handles database transactions that perform 
read-write operations.  Each machine can now interface with its own 
local database; in most client/server databases, this vastly increases 
performance.\par
\fi720\plain\f0\fs20 All components of the web site are analyzed for 
transaction type and classified as either containing or not containing 
a read-write database transaction.  All incoming requests will be 
naively distributed across the 6 front-end web servers.  Any request 
that requires a read-write transaction will be reallocated to the 
database server for service.  All other requests will be reallocated to 
the machine on which it will cost the least (in resources) to satisfy.  
Of course, analysis of certain database queries (like full table scans) 
may show that overall performance will increase if those transactions 
were always made to the database server.\par
\fi0\plain\f0\fs20\par
\plain\f1\b Future Directions\par
\plain\f0\fs20 Several technical design and implementation issues that 
must be tackled before any major augmentations are done.  The first is 
to design more elegant support for SSL enabled connections.  The second 
is to eliminate the need for an entire Apache child process to be 
blocked while proxying a request.  One or more RMA type processes 
should be created that normal child processes can hand requests to for 
proxying.  Each of these dedicated proxying processes can handle a 
multiplicity of active requests using select()/poll() semantics and 
asynchronous I/O.  A mechanism for handing a client back to a normal 
child process must be investigated.\par
\fi720\plain\f0\fs20 There are a few places we would like to see the 
mod_backhand project go in the bigger picture.  The first is back into 
the research stage from whence it came.  Analysis on the effectiveness 
of the decision making and reallocation of requests is necessary for 
any major improvement. The other place is the wide area scenarios.  
Though much of the wide area load balancing problem is better tackle 
under a more general project like Backhand, mod_backhand could 
specifically benefit from the use of HTTP redirections for wide area 
balancing.\par
\fi0\plain\f0\fs20\par
\plain\f1\b Acknowledgements\par
\plain\f0\fs20 The Backhand project was started at the Center for 
Networks and Distributed Systems at The Johns Hopkins University.  This 
project would not have been possible with out the excellent 
collaborative environment for research and development found at CNDS.  
Many thanks to my advisor, Yair Amir (yairamir@cnds.jhu.edu), for 
constantly nudging me in the right direction.  Also, many of the design 
and implementation details inside mod_backhand's architecture are the 
product of collaborative work with Alec Peterson (ahp@hilander.com) and 
Jonathan Stanton (jonathan@cnds.jhu.edu).  The implementation and 
integration of the cost-benefit framework were done by Ryan Borgstrom 
(rsean@cs.jhu.edu); the specific tunings and adaptations to web server 
were a collaborative effort from Amir, Borgstrom, and myself.\par
\plain\f0\fs20\tab Many thanks go out to all of those who have written 
in with bugs, congratulations and success stories.\par
\plain\f0\fs20\par
\sect
}
